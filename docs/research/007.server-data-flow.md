# 007. 服务器端数据流与状态管理

## 概述

说明服务器端的数据流向、状态管理机制和认证流程。

---

## 请求处理流程

### 中间件洋葱模型

```
HTTP 请求
    ↓
RequestLoggingMiddleware
    ├─ 生成 request_id (UUID)
    ├─ 记录开始时间
    └─ await call_next()
    ↓
CrossOriginMiddleware
    ├─ 处理 CORS 头
    └─ await call_next()
    ↓
ErrorHandlingMiddleware
    ├─ try: await call_next()
    └─ except: 捕获异常
    ↓
路由处理函数
    ├─ Pydantic 验证
    ├─ Depends 注入
    ├─ 执行业务逻辑
    └─ 返回响应
    ↓
响应返回 (按相反顺序经过各中间件)
```

### 中间件顺序

**位置**: `server/src/app/main.py`

1. **RequestLogging** (最外层) - 日志记录
2. **CrossOrigin** (中间层) - CORS 处理
3. **ErrorHandling** (最内层) - 异常捕获

---

## 认证数据流

### 登录流程

```
POST /api/client/auth/login
    ↓
检查 IP 封禁
    ↓
检查登录频率限制
    ↓
验证邮箱和密码
    ↓
user_auth_service.authenticate_user()
    ├─ 查询用户
    ├─ 验证密码 (bcrypt)
    └─ 检查锁定状态
    ↓
create_tokens_for_user()
    ├─ 生成 Access Token (24h)
    ├─ 生成 Refresh Token (7天)
    └─ 存储到 Redis
    ↓
更新登录统计
    ↓
返回 Token
```

### Token 验证流程

```
请求携带 Authorization: Bearer {token}
    ↓
get_current_user (依赖注入)
    ↓
JwtUnit.decode(token)
    ├─ 验证签名
    └─ 验证过期时间
    ↓
user_token_service.verify_token()
    └─ Redis ZSCORE 检查
    ↓
返回 UserContext
    {
      user_id: int,
      token: str,
      device_id: str?,
      language: str,
      ip: str?
    }
    ↓
业务逻辑执行
```

### Token 轮换

```
用户使用 Refresh Token 请求新 Access Token
    ↓
验证 Refresh Token 有效性
    ↓
生成新的 Access Token 和 Refresh Token
    ↓
将旧 Refresh Token 移到 refresh_token_old:{user_id}
    (宽限期 30s，处理并发请求)
    ↓
存储新的 Refresh Token
    ↓
返回新 Token
```

---

## Redis 数据结构

### Token 存储

```
# Access Token (按过期时间排序)
access_token:{user_id} → ZSet [
  md5(token1) = expires_at1,
  md5(token2) = expires_at2,
  ...
]

# Refresh Token
refresh_token:{user_id} → ZSet [
  md5(token1) = expires_at1,
  ...
]

# 旧 Refresh Token (宽限期 30s)
refresh_token_old:{user_id} → ZSet [
  md5(old_token) = expires_at + 30s
]
```

### 限流数据

```
# IP 限流
rate_limit:{ip}:{endpoint} → String (请求次数)

# 登录尝试
login_attempts:{email} → String (尝试次数)

# IP 封禁
ip_blocked:{ip} → String (封禁到期时间)
```

### 缓存策略

**用户信息缓存**:
```
Key: user:info:{user_id}
TTL: 300s (5分钟)
Value: {id, email, nickname, ...}
```

**Token 验证缓存**:
```
Key: token:verify:{md5(token)}
TTL: 60s
Value: user_id
```

---

## 数据库事务

### 事务管理

**位置**: `server/src/app/core/database.py`

**上下文管理器**:
```python
async def get_async_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_maker() as session:
        try:
            yield session
            await session.commit()  # 成功提交
        except:
            await session.rollback()  # 失败回滚
            raise
```

### 使用方式

```python
@router.post("/create")
async def create_order(
    data: OrderCreate,
    current_user: UserContext = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session)
):
    # 自动事务管理
    order = await order_service.create_order(db, current_user.user_id, data)
    return ResponseUtils.ok(order)
```

---

## 错误处理

### 异常层次

```
Exception
    ↓
AppCommonException (业务异常)
    ├─ UserNotFoundException
    ├─ UserAuthFailedException
    ├─ OrderNotFoundException
    └─ ...
    ↓
ValidationError (参数验证错误)
    ↓
Exception (系统异常)
```

### 中间件处理

**位置**: `server/src/app/middleware/error_handling.py`

```python
class ErrorHandlingMiddleware:
    async def dispatch(self, request, call_next):
        try:
            return await call_next(request)
        except AppCommonException as e:
            # 业务异常，翻译错误消息
            return ResponseUtils.error(e.code, e.msg)
        except ValidationError as e:
            # 参数验证错误
            return ResponseUtils.error(CommonCode.VALIDATION_ERROR, str(e))
        except Exception as e:
            # 未知异常，记录日志
            logger.error(f"Unhandled exception: {e}")
            return ResponseUtils.error(CommonCode.INTERNAL_SERVER_ERROR)
```

### 错误代码

**位置**: `server/src/app/i18n/common_code.py`

**分类**:
- SUCCESS (10000)
- VALIDATION_ERROR (10001)
- USER_NOT_FOUND (10104)
- AUTH_INVALID_CREDENTIALS (10006)
- ORDER_NOT_FOUND (20001)

---

## 性能优化

### 连接池

**数据库连接池** (`server/src/app/core/database.py`):
- pool_size: 20 (常驻连接)
- max_overflow: 40 (最大溢出连接)
- pool_recycle: 3600s (连接回收)
- pool_pre_ping: True (连接前检查)

**Redis 连接池** (`server/src/app/core/redis.py`):
- pool_size: 5000
- socket_timeout: 5s
- socket_connect_timeout: 5s

### 缓存策略

**用户信息**: TTL 5 分钟，减少数据库查询

**Token 验证**: TTL 60 秒，减少 Redis 查询

**限流数据**: 根据业务需求设置 TTL

### 数据库优化

**索引优化**: email, order_no 等关键字段建立索引

**查询优化**: 使用 SQLAlchemy ORM 的懒加载和预加载

**连接复用**: 连接池自动管理，避免频繁建立连接

---

## 相关文档

- [001. 基础架构](./001.basic-architecture.md)
- [003. 服务器端架构](./003.server-architecture.md)
- [005. 部署与配置](./005.deployment-and-config.md)
